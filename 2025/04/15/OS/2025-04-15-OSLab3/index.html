<!-- build time:Wed Apr 23 2025 16:49:25 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="碼農書架" href="http://circlecoder05.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="碼農書架" href="http://circlecoder05.github.io/atom.xml"><link rel="alternate" type="application/json" title="碼農書架" href="http://circlecoder05.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="实验,OS"><link rel="canonical" href="http://circlecoder05.github.io/2025/04/15/OS/2025-04-15-OSLab3/"><title>OS-Lab3-进程与异常 - 操作系统 | CircleCoder = 碼農書架 = 仰望星空</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">OS-Lab3-进程与异常</h1><div class="meta"><span class="item" title="创建时间：2025-04-15 00:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2025-04-15T00:00:00+08:00">2025-04-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>15k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>28 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">CircleCoder</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://circlecoder05.oss-cn-beijing.aliyuncs.com/test/202503311943222.jpg"></li><li class="item" data-background-image="https://circlecoder05.oss-cn-beijing.aliyuncs.com/test/202503311945788.jpg"></li><li class="item" data-background-image="https://circlecoder05.oss-cn-beijing.aliyuncs.com/test/202503311944494.jpg"></li><li class="item" data-background-image="https://circlecoder05.oss-cn-beijing.aliyuncs.com/test/202503311942090.jpg"></li><li class="item" data-background-image="https://circlecoder05.oss-cn-beijing.aliyuncs.com/test/202503311944606.jpg"></li><li class="item" data-background-image="https://circlecoder05.oss-cn-beijing.aliyuncs.com/test/202503292158821.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/OS/" itemprop="item" rel="index" title="分类于 操作系统"><span itemprop="name">操作系统</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://circlecoder05.github.io/2025/04/15/OS/2025-04-15-OSLab3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="CircleCoder"><meta itemprop="description" content="仰望星空, 空天报国，敢为人先"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="碼農書架"></span><div class="body md" itemprop="articleBody"><p></p><div class="media-container"><div class="player" data-type="audio" data-src='["https://music.163.com/#/song?id=5285268"]'></div></div><p></p><h3 id="实验目的"><a class="anchor" href="#实验目的">#</a> 实验目的</h3><ol><li>创建一个进程并成功运行</li><li>实现时钟中断，通过时钟中断内核可以再次获得执行权</li><li>实现进程调度，创建两个进程，并且通过时钟中断切换进程执行</li></ol><p>在 Lab3 中将运行一个用户模式的进程。</p><p>本实验需要使用数据结构进程控制块 Env 来跟踪用户进程，并建立一个简单的用户进程，加载一个程序镜像到指定的内存空间，然后让它运行起来。</p><p>同时，实验实现的 MIPS 内核具有处理异常的能力。</p><hr><h3 id="进程控制块"><a class="anchor" href="#进程控制块">#</a> 进程控制块</h3><h4 id="进程控制块-pcb"><a class="anchor" href="#进程控制块-pcb">#</a> 进程控制块 PCB</h4><p>进程控制块 (PCB) 是系统专门设置用来管理进程的数据结构，它可以记录进程的外部特征，描述进程的变化过程。系统利用 PCB 来控制和管理进程，所以 <strong>PCB</strong> 是系统感知进程存在的唯一标志。进程与 <strong>PCB</strong> 是一一对应的。在 MOS 中，PCB 由一个 Env 结构体实现，主要包含如下一些信息（只展示本次实验用到的）</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> env_tf<span class="token punctuation">;</span>	 	<span class="token comment">// 保存进程上下文信息的结构体</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token function">LIST_ENTRY</span><span class="token punctuation">(</span>Env<span class="token punctuation">)</span> env_link<span class="token punctuation">;</span>	 	<span class="token comment">// 链表项，类似于 Lab2 中的 pp_link，用于构造队列 env_free_list</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	u_int env_id<span class="token punctuation">;</span>			 		<span class="token comment">// 每个进程独一无二的标识符</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	u_int env_asid<span class="token punctuation">;</span>			 		<span class="token comment">// ASID of this env</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	u_int env_parent_id<span class="token punctuation">;</span>		 	<span class="token comment">// 父进程的 env_id，可通过此关联形成树</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	u_int env_status<span class="token punctuation">;</span>		 		<span class="token comment">// 进程状态，有三种取值：空闲态、阻塞态、就绪运行态</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	Pde <span class="token operator">*</span>env_pgdir<span class="token punctuation">;</span>			 		<span class="token comment">// 进程页目录的内核虚拟地址</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token function">TAILQ_ENTRY</span><span class="token punctuation">(</span>Env<span class="token punctuation">)</span> env_sched_link<span class="token punctuation">;</span> <span class="token comment">// 链表项，用于构造调度队列 env_sched_list</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	u_int env_pri<span class="token punctuation">;</span>			 		<span class="token comment">// 进程优先级</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h4 id="env_init-函数"><a class="anchor" href="#env_init-函数">#</a> env_init 函数</h4><p>该函数的功能是：</p><ul><li>初始化空闲 <code>PCB</code> 链表 和 已分配的 <code>PCB</code> 链表</li><li>初始时，所有 <code>PCB</code> 都是空闲的，将它们全部加入空闲链表中。为了使编号较小的 <code>PCB</code> 优先被分配，即不改变数组中原有顺序，需要 <strong>倒序遍历</strong>，插入头部</li><li>我们需要一个模板页目录 <code>base_dir</code> ，<strong>将两个内核数组（Pages 和 Envs）映射到用户空间（UPAGES 和 UENVS）</strong>，供用户程序读取。之后每新建一个进程，都会复制这份模板页目录，共享这两个信息（只读）</li></ul><h4 id="exercise-31"><a class="anchor" href="#exercise-31">#</a> Exercise 3.1</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">env_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">int</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token comment">/* Step 1: Initialize 'env_free_list' with 'LIST_INIT' and 'env_sched_list' with</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	 * 'TAILQ_INIT'. */</pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token comment">/* Exercise 3.1: Your code here. (1/2) */</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token function">LIST_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_free_list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token function">TAILQ_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token comment">/* Step 2: Traverse the elements of 'envs' array, set their status to 'ENV_FREE' and insert</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	 * them into the 'env_free_list'. Make sure, after the insertion, the order of envs in the</pre></td></tr><tr><td data-num="12"></td><td><pre>	 * list should be the same as they are in the 'envs' array. */</pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token comment">/* Exercise 3.1: Your code here. (2/2) */</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> NENV <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		envs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>env_status <span class="token operator">=</span> ENV_FREE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>		<span class="token function">LIST_INSERT_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_free_list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>envs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> env_link<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token comment">/*</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	 * We want to map 'UPAGES' and 'UENVS' to *every* user space with PTE_G permission (without</pre></td></tr><tr><td data-num="23"></td><td><pre>	 * PTE_D), then user programs can read (but cannot write) kernel data structures 'pages' and</pre></td></tr><tr><td data-num="24"></td><td><pre>	 * 'envs'.</pre></td></tr><tr><td data-num="25"></td><td><pre>	 *</pre></td></tr><tr><td data-num="26"></td><td><pre>	 * Here we first map them into the *template* page directory 'base_pgdir'.</pre></td></tr><tr><td data-num="27"></td><td><pre>	 * Later in 'env_setup_vm', we will copy them into each 'env_pgdir'.</pre></td></tr><tr><td data-num="28"></td><td><pre>	 */</pre></td></tr><tr><td data-num="29"></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>	<span class="token function">panic_on</span><span class="token punctuation">(</span><span class="token function">page_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>	p<span class="token operator">-></span>pp_ref<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>	base_pgdir <span class="token operator">=</span> <span class="token punctuation">(</span>Pde <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">page2kva</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>	<span class="token function">map_segment</span><span class="token punctuation">(</span>base_pgdir<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">PADDR</span><span class="token punctuation">(</span>pages<span class="token punctuation">)</span><span class="token punctuation">,</span> UPAGES<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="35"></td><td><pre>				<span class="token function">ROUND</span><span class="token punctuation">(</span>npage <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Page</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_G<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>	<span class="token function">map_segment</span><span class="token punctuation">(</span>base_pgdir<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">PADDR</span><span class="token punctuation">(</span>envs<span class="token punctuation">)</span><span class="token punctuation">,</span> UENVS<span class="token punctuation">,</span> <span class="token function">ROUND</span><span class="token punctuation">(</span>NENV <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="37"></td><td><pre>				PTE_G<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="map_segment-函数"><a class="anchor" href="#map_segment-函数">#</a> map_segment 函数</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">map_segment</span><span class="token punctuation">(</span>Pde <span class="token operator">*</span>pgdir<span class="token punctuation">,</span> u_int asid<span class="token punctuation">,</span> u_long pa<span class="token punctuation">,</span> u_long va<span class="token punctuation">,</span> u_long size<span class="token punctuation">,</span> u_int perm<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>功能是在一级页表基地址 <code>pgdir</code> 对应的两级页表结构中做段地址映射，将虚拟地址段 <code>[va, va+size)</code> 映射到物理地址段 <code>[pa, pa+size)</code> 。<strong>即区域化的 <code>page_insert</code> </strong>。因为是 <strong>按页映射</strong>，要求 <code>size</code> 必须是页面大小的整数倍</p><p>它在 <code>env_init</code> 中的作用是将内核中的 <code>Page</code> 和 <code>Env</code> 数据结构映射到用户地址，以供用户程序读取</p><h4 id="exercise-32"><a class="anchor" href="#exercise-32">#</a> Exercise 3.2</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">map_segment</span><span class="token punctuation">(</span>Pde <span class="token operator">*</span>pgdir<span class="token punctuation">,</span> u_int asid<span class="token punctuation">,</span> u_long pa<span class="token punctuation">,</span> u_long va<span class="token punctuation">,</span> u_int size<span class="token punctuation">,</span> u_int perm<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token function">assert</span><span class="token punctuation">(</span>pa <span class="token operator">%</span> PAGE_SIZE <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token function">assert</span><span class="token punctuation">(</span>va <span class="token operator">%</span> PAGE_SIZE <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token function">assert</span><span class="token punctuation">(</span>size <span class="token operator">%</span> PAGE_SIZE <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token comment">/* Step 1: Map virtual address space to physical address space. */</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i <span class="token operator">+=</span> PAGE_SIZE<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>		<span class="token comment">/*</span></pre></td></tr><tr><td data-num="12"></td><td><pre>		 * Hint:</pre></td></tr><tr><td data-num="13"></td><td><pre>		 *  Map the virtual page 'va + i' to the physical page 'pa + i' using 'page_insert'.</pre></td></tr><tr><td data-num="14"></td><td><pre>		 *  Use 'pa2page' to get the 'struct Page *' of the physical address.</pre></td></tr><tr><td data-num="15"></td><td><pre>		 */</pre></td></tr><tr><td data-num="16"></td><td><pre>		<span class="token comment">/* Exercise 3.2: Your code here. */</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		<span class="token function">page_insert</span><span class="token punctuation">(</span>pgdir<span class="token punctuation">,</span> asid<span class="token punctuation">,</span> <span class="token function">pa2page</span><span class="token punctuation">(</span>pa <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="env_setup_vm-函数"><a class="anchor" href="#env_setup_vm-函数">#</a> env_setup_vm 函数</h4><p>该函数用于为一个新进程的 <code>PCB</code> 设置初始的虚拟内存布局，即初始化页目录</p><p>首先需要了解 <strong>用户空间的地址划分</strong></p><p><img data-src="https://circlecoder05.oss-cn-beijing.aliyuncs.com/test/202504151501322.png" alt="359b083e002b5421f09cdcc418ee9ef"></p><ul><li><p>首先需要申请一个物理页，作为给 <code>PCB</code> 分配的页目录</p></li><li><p>将模板页目录拷贝至该 <code>PCB</code> 的页目录，使得进程能够共享 <code>Pages</code> 和 <code>Envs</code> （只读），获取其他进程的信息</p><p>拷贝范围： <code>[UTOP , UVPT)</code> 中的所有页目录项</p></li><li><p><strong>页表自映射</strong>：特殊虚拟地址 <code>UVPT</code> <strong>映射到该进程页目录本身的物理地址</strong></p></li></ul><h4 id="exercise-33"><a class="anchor" href="#exercise-33">#</a> Exercise 3.3</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">env_setup_vm</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token comment">/* Step 1:</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	 *   Allocate a page for the page directory with 'page_alloc'.</pre></td></tr><tr><td data-num="5"></td><td><pre>	 *   Increase its 'pp_ref' and assign its kernel address to 'e->env_pgdir'.</pre></td></tr><tr><td data-num="6"></td><td><pre>	 *</pre></td></tr><tr><td data-num="7"></td><td><pre>	 * Hint:</pre></td></tr><tr><td data-num="8"></td><td><pre>	 *   You can get the kernel address of a specified physical page using 'page2kva'.</pre></td></tr><tr><td data-num="9"></td><td><pre>	 */</pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token function">try</span><span class="token punctuation">(</span><span class="token function">page_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token comment">/* Exercise 3.3: Your code here. */</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	p<span class="token operator">-></span>pp_ref<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	e<span class="token operator">-></span>env_pgdir <span class="token operator">=</span> <span class="token punctuation">(</span>Pde <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">page2kva</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token comment">/* Step 2: Copy the template page directory 'base_pgdir' to 'e->env_pgdir'. */</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token comment">/* Hint:</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	 *   As a result, the address space of all envs is identical in [UTOP, UVPT).</pre></td></tr><tr><td data-num="19"></td><td><pre>	 *   See include/mmu.h for layout.</pre></td></tr><tr><td data-num="20"></td><td><pre>	 */</pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token function">memcpy</span><span class="token punctuation">(</span>e<span class="token operator">-></span>env_pgdir <span class="token operator">+</span> <span class="token function">PDX</span><span class="token punctuation">(</span>UTOP<span class="token punctuation">)</span><span class="token punctuation">,</span> base_pgdir <span class="token operator">+</span> <span class="token function">PDX</span><span class="token punctuation">(</span>UTOP<span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="22"></td><td><pre>		   <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Pde<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token function">PDX</span><span class="token punctuation">(</span>UVPT<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">PDX</span><span class="token punctuation">(</span>UTOP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>	<span class="token comment">/* Step 3: Map its own page table at 'UVPT' with readonly permission.</span></pre></td></tr><tr><td data-num="25"></td><td><pre>	 * As a result, user programs can read its page table through 'UVPT' */</pre></td></tr><tr><td data-num="26"></td><td><pre>	e<span class="token operator">-></span>env_pgdir<span class="token punctuation">[</span><span class="token function">PDX</span><span class="token punctuation">(</span>UVPT<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">PADDR</span><span class="token punctuation">(</span>e<span class="token operator">-></span>env_pgdir<span class="token punctuation">)</span> <span class="token operator">|</span> PTE_V<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="env_alloc-函数"><a class="anchor" href="#env_alloc-函数">#</a> env_alloc 函数</h4><p>该函数的功能是申请并初始化一个进程控制块 <code>PCB</code> ，具体工作如下：</p><ul><li><p>取出空闲 <code>PCB</code></p></li><li><p>调用 <code>env_setup_vm</code> 初始化其页目录</p></li><li><p>设置 <code>env_id</code> 、 <code>env_asid</code> 和 <code>env_parent_id</code></p></li><li><p>初始化 <code>CP0_status</code></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>e<span class="token operator">-></span>env_tf<span class="token punctuation">.</span>cp0_status <span class="token operator">=</span> STATUS_IM7 <span class="token operator">|</span> STATUS_IE <span class="token operator">|</span> STATUS_EXL <span class="token operator">|</span> STATUS_UM<span class="token punctuation">;</span></pre></td></tr></table></figure><p>这几个宏代表相应位置 1</p><ul><li><code>IE</code> 和 <code>IM7</code> 置 1，表示中断使能，且 7 号中断（时钟中断）可以被响应</li><li><code>EXL</code> 置 1，表示强制内核模式。每当异常发生时， <code>EXL</code> 会被自动置 1，然后进入异常处理程序；每次 <code>eret</code> 后， <code>EXL</code> 会自动置 0</li><li><code>UM</code> 置 1，且 <code>EXL</code> 为 0 时，表示用户模式</li></ul></li><li><p>初始化栈指针。栈寄存器是第 29 号寄存器，注意这里的栈是 <strong>用户栈</strong>，不是内核栈。栈是用来处理函数的（比如用户的 main 函数），函数就要传参</p><p><code>USTACKTOP - sizeof(int) - sizeof(char \**)</code></p><ul><li><code>sizeof(int)</code> 是为 <code>argc</code> （参数个数，一个整数）预留空间。</li><li><code>sizeof(char **)</code> 是为 <code>argv</code> （参数向量，一个指向字符串指针数组的指针）预留空间。</li></ul></li><li><p>将该 <code>PCB</code> 从空闲链表中移除并返回</p></li></ul><h4 id="exercise-34"><a class="anchor" href="#exercise-34">#</a> Exercise 3.4</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">env_alloc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span><span class="token operator">*</span>new<span class="token punctuation">,</span> u_int parent_id<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">int</span> r<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token comment">/* Step 1: Get a free Env from 'env_free_list' */</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token comment">/* Exercise 3.4: Your code here. (1/4) */</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	e <span class="token operator">=</span> <span class="token function">LIST_FIRST</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_free_list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>		<span class="token keyword">return</span> <span class="token operator">-</span>E_NO_FREE_ENV<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token comment">/* Step 2: Call a 'env_setup_vm' to initialize the user address space for this new Env. */</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token comment">/* Exercise 3.4: Your code here. (2/4) */</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token function">try</span><span class="token punctuation">(</span><span class="token function">env_setup_vm</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token comment">/* Step 3: Initialize these fields for the new Env with appropriate values:</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	 *   'env_user_tlb_mod_entry' (lab4), 'env_runs' (lab6), 'env_id' (lab3), 'env_asid' (lab3),</pre></td></tr><tr><td data-num="20"></td><td><pre>	 *   'env_parent_id' (lab3)</pre></td></tr><tr><td data-num="21"></td><td><pre>	 *</pre></td></tr><tr><td data-num="22"></td><td><pre>	 * Hint:</pre></td></tr><tr><td data-num="23"></td><td><pre>	 *   Use 'asid_alloc' to allocate a free asid.</pre></td></tr><tr><td data-num="24"></td><td><pre>	 *   Use 'mkenvid' to allocate a free envid.</pre></td></tr><tr><td data-num="25"></td><td><pre>	 */</pre></td></tr><tr><td data-num="26"></td><td><pre>	e<span class="token operator">-></span>env_user_tlb_mod_entry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// for lab4</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	e<span class="token operator">-></span>env_runs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>			   <span class="token comment">// for lab6</span></pre></td></tr><tr><td data-num="28"></td><td><pre>	<span class="token comment">/* Exercise 3.4: Your code here. (3/4) */</span></pre></td></tr><tr><td data-num="29"></td><td><pre>	<span class="token function">try</span><span class="token punctuation">(</span><span class="token function">asid_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e<span class="token operator">-></span>env_asid<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>	e<span class="token operator">-></span>env_id <span class="token operator">=</span> <span class="token function">mkenvid</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>	e<span class="token operator">-></span>env_parent_id <span class="token operator">=</span> parent_id<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>	<span class="token comment">/* Step 4: Initialize the sp and 'cp0_status' in 'e->env_tf'.</span></pre></td></tr><tr><td data-num="34"></td><td><pre>	 *   Set the EXL bit to ensure that the processor remains in kernel mode during context</pre></td></tr><tr><td data-num="35"></td><td><pre>	 * recovery. Additionally, set UM to 1 so that when ERET unsets EXL, the processor</pre></td></tr><tr><td data-num="36"></td><td><pre>	 * transitions to user mode.</pre></td></tr><tr><td data-num="37"></td><td><pre>	 */</pre></td></tr><tr><td data-num="38"></td><td><pre>	e<span class="token operator">-></span>env_tf<span class="token punctuation">.</span>cp0_status <span class="token operator">=</span> STATUS_IM7 <span class="token operator">|</span> STATUS_IE <span class="token operator">|</span> STATUS_EXL <span class="token operator">|</span> STATUS_UM<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>	<span class="token comment">// Reserve space for 'argc' and 'argv'.</span></pre></td></tr><tr><td data-num="40"></td><td><pre>	e<span class="token operator">-></span>env_tf<span class="token punctuation">.</span>regs<span class="token punctuation">[</span><span class="token number">29</span><span class="token punctuation">]</span> <span class="token operator">=</span> USTACKTOP <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre></pre></td></tr><tr><td data-num="42"></td><td><pre>	<span class="token comment">/* Step 5: Remove the new Env from env_free_list. */</span></pre></td></tr><tr><td data-num="43"></td><td><pre>	<span class="token comment">/* Exercise 3.4: Your code here. (4/4) */</span></pre></td></tr><tr><td data-num="44"></td><td><pre>	<span class="token function">LIST_REMOVE</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> env_link<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre></pre></td></tr><tr><td data-num="46"></td><td><pre>	<span class="token operator">*</span>new <span class="token operator">=</span> e<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><hr><h3 id="加载二进制映像"><a class="anchor" href="#加载二进制映像">#</a> 加载二进制映像</h3><p>要想正确加载一个 ELF 文件到内存，只需将 ELF 文件中所有需要加载的程序段（programsegment）加载到对应的虚拟地址上即可。</p><h4 id="elf_from-函数"><a class="anchor" href="#elf_from-函数">#</a> elf_from 函数</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">const</span> Elf32_Ehdr <span class="token operator">*</span><span class="token function">elf_from</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token keyword">const</span> Elf32_Ehdr <span class="token operator">*</span>ehdr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Elf32_Ehdr <span class="token operator">*</span><span class="token punctuation">)</span>binary<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Elf32_Ehdr<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ehdr<span class="token operator">-></span>e_ident<span class="token punctuation">[</span>EI_MAG0<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG0 <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	    ehdr<span class="token operator">-></span>e_ident<span class="token punctuation">[</span>EI_MAG1<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG1 <span class="token operator">&amp;&amp;</span> ehdr<span class="token operator">-></span>e_ident<span class="token punctuation">[</span>EI_MAG2<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG2 <span class="token operator">&amp;&amp;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	    ehdr<span class="token operator">-></span>e_ident<span class="token punctuation">[</span>EI_MAG3<span class="token punctuation">]</span> <span class="token operator">==</span> ELFMAG3 <span class="token operator">&amp;&amp;</span> ehdr<span class="token operator">-></span>e_type <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>		<span class="token keyword">return</span> ehdr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>此函数通过强制转换完成了对 ELF 文件的初步解析，并检查各字段是否有效</p><h4 id="elf_load_seg-函数"><a class="anchor" href="#elf_load_seg-函数">#</a> elf_load_seg 函数</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token function">elf_load_seg</span><span class="token punctuation">(</span>Elf32_Phdr <span class="token operator">*</span>ph<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>bin<span class="token punctuation">,</span> <span class="token class-name">elf_mapper_t</span> map_page<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	u_long va <span class="token operator">=</span> ph<span class="token operator">-></span>p_vaddr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token class-name">size_t</span> bin_size <span class="token operator">=</span> ph<span class="token operator">-></span>p_filesz<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token class-name">size_t</span> sgsize <span class="token operator">=</span> ph<span class="token operator">-></span>p_memsz<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	u_int perm <span class="token operator">=</span> PTE_V<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>ph<span class="token operator">-></span>p_flags <span class="token operator">&amp;</span> PF_W<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>		perm <span class="token operator">|=</span> PTE_D<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token keyword">int</span> r<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token class-name">size_t</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	u_long offset <span class="token operator">=</span> va <span class="token operator">-</span> <span class="token function">ROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>offset <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">map_page</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> va<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> perm<span class="token punctuation">,</span> bin<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="15"></td><td><pre>				  <span class="token function">MIN</span><span class="token punctuation">(</span>bin_size<span class="token punctuation">,</span> PAGE_SIZE <span class="token operator">-</span> offset<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>			<span class="token keyword">return</span> r<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>	<span class="token comment">/* Step 1: load all content of bin into memory. */</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> offset <span class="token operator">?</span> <span class="token function">MIN</span><span class="token punctuation">(</span>bin_size<span class="token punctuation">,</span> PAGE_SIZE <span class="token operator">-</span> offset<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bin_size<span class="token punctuation">;</span> i <span class="token operator">+=</span> PAGE_SIZE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">map_page</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> perm<span class="token punctuation">,</span> bin <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>bin_size <span class="token operator">-</span> i<span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span></pre></td></tr><tr><td data-num="23"></td><td><pre>		    <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>			<span class="token keyword">return</span> r<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>	<span class="token comment">/* Step 2: alloc pages to reach `sgsize` when `bin_size` &lt; `sgsize`. */</span></pre></td></tr><tr><td data-num="29"></td><td><pre>	<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> sgsize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>r <span class="token operator">=</span> <span class="token function">map_page</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> va <span class="token operator">+</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> perm<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token function">MIN</span><span class="token punctuation">(</span>sgsize <span class="token operator">-</span> i<span class="token punctuation">,</span> PAGE_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>			<span class="token keyword">return</span> r<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>		i <span class="token operator">+=</span> PAGE_SIZE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>该函数的功能是将 <code>ELF</code> 文件的一个段加载到内存当中</p><p>参数说明：</p><ul><li><code>ph</code> ：指向段头的指针，包含段加载信息</li><li><code>bin</code> ：指向该段二进制数据的指针</li><li><code>map_page</code> ：页面映射回调函数。每当 <code>elf_load_seg</code> 函数解析到一个需要加载到内存中的页面，会将有关的信息作为参数传递给回调函数，并由它完成单个页面的加载过程</li><li><code>data</code> ：传递给回调函数的额外数据</li></ul><p><code>elf_load_seg</code> 函数会从 ph 中获取 va（该段需要被加载到的虚地址）、 <code>sgsize</code> （该段在内存中的大小）、 <code>bin_size</code> （该段在文件中的大小）和 <code>perm</code> （该段被加载时的页面权限），并根据这些信息完成以下两个步骤：</p><ul><li>加载该段的所有数据（bin）中的所有内容到内存（va）。</li><li>如果该段在文件中的内容的大小达不到为填入这段内容新分配的页面大小，即分配了新的页面但没能填满（如 .bss 区域），那么余下的部分用 0 来填充。</li></ul><p><code>elf_load_seg</code> 只关心 <code>ELF</code> 段的结构，而不用处理与具体操作系统相关的页面加载过程</p><h4 id="load_icode_mapper-函数"><a class="anchor" href="#load_icode_mapper-函数">#</a> load_icode_mapper 函数</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">load_icode_mapper</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> u_long va<span class="token punctuation">,</span> <span class="token class-name">size_t</span> offset<span class="token punctuation">,</span> u_int perm<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>是一个页面级别的内存映射辅助函数，用于在加载 <code>ELF</code> 可执行文件时处理单个页面的映射，是 <code>elf_load_seg</code> 中回调函数 <code>map_page</code> 的实现</p><p>参数说明：</p><ul><li><code>data</code> ：指向进程控制块的指针</li><li><code>va</code> ：目标虚拟地址</li><li><code>offset</code> ：在页面内的偏移量</li><li><code>perm</code> ：页面权限标志</li><li><code>src</code> ：源数据指针 (要拷贝的内容)</li><li><code>len</code> ：要拷贝的数据长度</li></ul><p>工作流程：</p><ul><li>分配一个物理页面 <code>p</code></li><li>若 <code>src</code> 非空，则利用 <code>memcpy</code> 函数，将其拷贝到页面 <code>p</code> 中偏移量为 <code>offset</code> 的位置</li><li>建立页表映射，利用 <code>page_insert</code> 函数，插入到 <code>data</code> 所指的 <code>PCB</code> 的页目录中</li></ul><h4 id="exercise-35"><a class="anchor" href="#exercise-35">#</a> Exercise 3.5</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">load_icode_mapper</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> u_long va<span class="token punctuation">,</span> <span class="token class-name">size_t</span> offset<span class="token punctuation">,</span> u_int perm<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>src<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="2"></td><td><pre>							 <span class="token class-name">size_t</span> len<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>env <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span><span class="token punctuation">)</span>data<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">Page</span> <span class="token operator">*</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">int</span> r<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token comment">/* Step 1: Allocate a page with 'page_alloc'. */</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token comment">/* Exercise 3.5: Your code here. (1/2) */</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token function">try</span><span class="token punctuation">(</span><span class="token function">page_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token comment">/* Step 2: If 'src' is not NULL, copy the 'len' bytes started at 'src' into 'offset' at this</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	 * page. */</pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token comment">// Hint: You may want to use 'memcpy'.</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>src <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		<span class="token comment">/* Exercise 3.5: Your code here. (2/2) */</span></pre></td></tr><tr><td data-num="18"></td><td><pre>		<span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">page2kva</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">+</span> offset<span class="token punctuation">,</span> src<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token comment">/* Step 3: Insert 'p' into 'env->env_pgdir' at 'va' with 'perm'. */</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	<span class="token keyword">return</span> <span class="token function">page_insert</span><span class="token punctuation">(</span>env<span class="token operator">-></span>env_pgdir<span class="token punctuation">,</span> env<span class="token operator">-></span>env_asid<span class="token punctuation">,</span> p<span class="token punctuation">,</span> va<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="load_icode-函数"><a class="anchor" href="#load_icode-函数">#</a> load_icode 函数</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">load_icode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这个函数便是完整加载镜像的总函数，通过调用 <code>elf_load_seg</code> 函数来将 <code>ELF</code> 文件真正加载到内存中，将 <code>load_icode_mapper</code> 作为参数传入</p><p>工作流程：</p><ul><li><p>根据魔数，验证 <code>ELF</code> 文件头的合法性</p></li><li><p>段加载过程。使用宏 <code>ELF_FOREACH_PHDR_OFF</code> 遍历所有程序段，对于每个类型为 <code>PT_LOAD</code> 的段：</p><ul><li>获取段在文件中的偏移量 ( <code>p_offset</code> )</li><li>调用 <code>elf_load_seg</code> 加载该段</li><li>使用 <code>load_icode_mapper</code> 作为页面映射回调函数</li><li>将当前进程控制块 <code>e</code> 作为 <code>data</code> 传递</li></ul></li><li><p>设置程序入口点。将程序计数器 ( <code>cp0_epc</code> ) 设置为 ELF 头中指定的入口地址 ( <code>e_entry</code> ) <strong>（虚拟地址）</strong></p><p>这里的 <code>env_tf.cp0_epc</code> 字段指示了进程恢复运行时 <code>PC</code> 应恢复到的位置。我们要运行的进程的代码段预先被载入到了内存中，且程序入口为 <code>e_entry</code> ，当我们运行进程时， <code>CPU</code> 将自动从 <code>PC</code> 所指的位置开始执行二进制码</p></li></ul><h4 id="exercise-36"><a class="anchor" href="#exercise-36">#</a> Exercise 3.6</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">load_icode</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token comment">/* Step 1: Use 'elf_from' to parse an ELF header from 'binary'. */</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">const</span> Elf32_Ehdr <span class="token operator">*</span>ehdr <span class="token operator">=</span> <span class="token function">elf_from</span><span class="token punctuation">(</span>binary<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ehdr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>		<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"bad elf at %x"</span><span class="token punctuation">,</span> binary<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token comment">/* Step 2: Load the segments using 'ELF_FOREACH_PHDR_OFF' and 'elf_load_seg'.</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	 * As a loader, we just care about loadable segments, so parse only program headers here.</pre></td></tr><tr><td data-num="12"></td><td><pre>	 */</pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token class-name">size_t</span> ph_off<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	<span class="token function">ELF_FOREACH_PHDR_OFF</span><span class="token punctuation">(</span>ph_off<span class="token punctuation">,</span> ehdr<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>		Elf32_Phdr <span class="token operator">*</span>ph <span class="token operator">=</span> <span class="token punctuation">(</span>Elf32_Phdr <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>binary <span class="token operator">+</span> ph_off<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span>ph<span class="token operator">-></span>p_type <span class="token operator">==</span> PT_LOAD<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>			<span class="token comment">// 'elf_load_seg' is defined in lib/elfloader.c</span></pre></td></tr><tr><td data-num="20"></td><td><pre>			<span class="token comment">// 'load_icode_mapper' defines the way in which a page in this segment</span></pre></td></tr><tr><td data-num="21"></td><td><pre>			<span class="token comment">// should be mapped.</span></pre></td></tr><tr><td data-num="22"></td><td><pre>			<span class="token function">panic_on</span><span class="token punctuation">(</span><span class="token function">elf_load_seg</span><span class="token punctuation">(</span>ph<span class="token punctuation">,</span> binary <span class="token operator">+</span> ph<span class="token operator">-></span>p_offset<span class="token punctuation">,</span> load_icode_mapper<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>	<span class="token comment">/* Step 3: Set 'e->env_tf.cp0_epc' to 'ehdr->e_entry'. */</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	<span class="token comment">/* Exercise 3.6: Your code here. */</span></pre></td></tr><tr><td data-num="28"></td><td><pre>	e<span class="token operator">-></span>env_tf<span class="token punctuation">.</span>cp0_epc <span class="token operator">=</span> ehdr<span class="token operator">-></span>e_entry<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><hr><h3 id="进程的创建和运行"><a class="anchor" href="#进程的创建和运行">#</a> 进程的创建和运行</h3><h4 id="env_create-函数"><a class="anchor" href="#env_create-函数">#</a> env_create 函数</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span><span class="token function">env_create</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> priority<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里需要指出，“创建进程” 是指在操作系统内核初始化时直接创建进程，而不是在通过 <code>fork</code> 等系统调用来创建进程。在 Lab4 中将介绍 <code>fork</code> 这一种进程创建的方式。创建进程的过程很简单，就是实现对上述个别函数的封装，<strong>分配一个新的 Env 结构体</strong>，<strong>设置进程控制块</strong>，并 <strong>将程序载入到目标进程的地址空间</strong> 即可完成。</p><h4 id="exrercise-37"><a class="anchor" href="#exrercise-37">#</a> Exrercise 3.7</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span><span class="token function">env_create</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>binary<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> priority<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token comment">/* Step 1: Use 'env_alloc' to alloc a new env, with 0 as 'parent_id'. */</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token comment">/* Exercise 3.7: Your code here. (1/3) */</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token function">panic_on</span><span class="token punctuation">(</span><span class="token function">env_alloc</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>e<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token comment">/* Step 2: Assign the 'priority' to 'e' and mark its 'env_status' as runnable. */</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token comment">/* Exercise 3.7: Your code here. (2/3) */</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	e<span class="token operator">-></span>env_pri <span class="token operator">=</span> priority<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	e<span class="token operator">-></span>env_status <span class="token operator">=</span> ENV_RUNNABLE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token comment">/* Step 3: Use 'load_icode' to load the image from 'binary', and insert 'e' into</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	 * 'env_sched_list' using 'TAILQ_INSERT_HEAD'. */</pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token comment">/* Exercise 3.7: Your code here. (3/3) */</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token function">load_icode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> binary<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token function">TAILQ_INSERT_HEAD</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">,</span> e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token keyword">return</span> e<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>本次实验还没有 <code>fork</code> ，所以也就没有父进程的概念。故 <code>env_alloc</code> 的参数 <code>parent_id</code> 传入默认值 0 即可</p><h4 id="env_run-函数"><a class="anchor" href="#env_run-函数">#</a> env_run 函数</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">env_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>这里运行一个新进程往往意味着是 <strong>进程切换</strong> ，而不是单纯的进程运行。进程切换，顾名思义，就是当前进程停下工作，让出 CPU 来运行另外的进程。所以其包含两部分内容：</p><ul><li><p>保存当前进程上下文 (如果当前没有运行的进程就跳过这一步)</p><p>我们只需要保存进程的上下文信息，包括通用寄存器、 <code>HI</code> 、 <code>LO</code> 和 <code>CP0</code> 中的 <code>Status</code> ， <code>EPC</code> ， <code>Cause</code> 和 <code>BadVAddr</code> 寄存器。进程控制块除了 <code>env_tf</code> 其他的字段在进程切换后还保留在原本的进程控制块中，并不会改变，因此不需要保存</p><p>在 <code>Lab3</code> 中，我们在本实验里的寄存器状态保存的地方是 <code>KSTACKTOP</code> 以下的一个 <code>sizeof(TrapFrame)</code> 大小的区域中。</p><p><code>curenv-&gt;env_tf = *((struct Trapframe)KSTACKTOP - 1)</code> 中的 <code>curenv-&gt;env_tf</code> 就是当前进程的上下文所存放的区域。我们将把 <code>KSTACKTOP</code> 之下的 <code>Trapframe</code> 拷贝到当前进程的 <code>env_tf</code> 中，以达到保存进程上下文的效果。</p></li><li><p>恢复要启动的进程的上下文，然后运行该进程。</p><ul><li><p>切换 <code>curenv</code> 为即将运行的进程。</p></li><li><p>设置全局变量 <code>cur_pgdir</code> 为当前进程页目录地址，在 <code>TLB</code> 重填时将用到该全局变量。</p></li><li><p>调用 <code>env_pop_tf</code> 函数，恢复现场、异常返回。</p><p>它是定义在 <code>kern/env_asm.S</code> 中的一个汇编函数。这个函数也呼应了我们前文提到的，进程每次被调度运行前一定会执行的 <code>eret</code> 汇编指令。</p></li></ul></li></ul><h4 id="exercise-38"><a class="anchor" href="#exercise-38">#</a> Exercise 3.8</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">env_run</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token function">assert</span><span class="token punctuation">(</span>e<span class="token operator">-></span>env_status <span class="token operator">==</span> ENV_RUNNABLE<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token comment">// WARNING BEGIN: DO NOT MODIFY FOLLOWING LINES!</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">MOS_PRE_ENV_RUN</span></span></pre></td></tr><tr><td data-num="6"></td><td><pre>	MOS_PRE_ENV_RUN_STMT</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token comment">// WARNING END</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token comment">/* Step 1:</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	 *   If 'curenv' is NULL, this is the first time through.</pre></td></tr><tr><td data-num="12"></td><td><pre>	 *   If not, we may be switching from a previous env, so save its context into</pre></td></tr><tr><td data-num="13"></td><td><pre>	 *   'curenv->env_tf' first.</pre></td></tr><tr><td data-num="14"></td><td><pre>	 */</pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>curenv<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		curenv<span class="token operator">-></span>env_tf <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">Trapframe</span> <span class="token operator">*</span><span class="token punctuation">)</span>KSTACKTOP <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>	<span class="token comment">/* Step 2: Change 'curenv' to 'e'. */</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	curenv <span class="token operator">=</span> e<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	curenv<span class="token operator">-></span>env_runs<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// lab6</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>	<span class="token comment">/* Step 3: Change 'cur_pgdir' to 'curenv->env_pgdir', switching to its address space. */</span></pre></td></tr><tr><td data-num="25"></td><td><pre>	<span class="token comment">/* Exercise 3.8: Your code here. (1/2) */</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	cur_pgdir <span class="token operator">=</span> curenv<span class="token operator">-></span>env_pgdir<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>	<span class="token comment">/* Step 4: Use 'env_pop_tf' to restore the curenv's saved context (registers) and return/go</span></pre></td></tr><tr><td data-num="29"></td><td><pre>	 * to user mode.</pre></td></tr><tr><td data-num="30"></td><td><pre>	 *</pre></td></tr><tr><td data-num="31"></td><td><pre>	 * Hint:</pre></td></tr><tr><td data-num="32"></td><td><pre>	 *  - You should use 'curenv->env_asid' here.</pre></td></tr><tr><td data-num="33"></td><td><pre>	 *  - 'env_pop_tf' is a 'noreturn' function: it restores PC from 'cp0_epc' thus not</pre></td></tr><tr><td data-num="34"></td><td><pre>	 *    returning to the kernel caller, making 'env_run' a 'noreturn' function as well.</pre></td></tr><tr><td data-num="35"></td><td><pre>	 */</pre></td></tr><tr><td data-num="36"></td><td><pre>	<span class="token comment">/* Exercise 3.8: Your code here. (2/2) */</span></pre></td></tr><tr><td data-num="37"></td><td><pre>	<span class="token function">env_pop_tf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>curenv<span class="token operator">-></span>env_tf<span class="token punctuation">,</span> curenv<span class="token operator">-></span>env_asid<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><hr><h3 id="中断与异常"><a class="anchor" href="#中断与异常">#</a> 中断与异常</h3><p>我们实验里认为中断是异常的一种，并且是 <strong>仅有的一种异步异常</strong></p><p>协处理器 <code>CP0</code> :</p><p><img data-src="https://circlecoder05.oss-cn-beijing.aliyuncs.com/test/202504222141570.png" alt="image-20250422214121410"></p><p><code>MIPS CPU</code> 处理一个异常时大致要完成四项工作：</p><ul><li>设置 <code>EPC</code> 指向从异常返回的地址。</li><li>设置 <code>EXL</code> 位，强制 <code>CPU</code> 进入内核态（行使更高级的特权）并禁止中断。</li><li>设置 <code>Cause</code> 寄存器，用于记录异常发生的原因。</li><li><code>CPU</code> 开始从异常入口位置取指，此后一切交给软件处理。</li></ul><h4 id="异常的分发"><a class="anchor" href="#异常的分发">#</a> 异常的分发</h4><p>当发生异常时，处理器会进入一个用于分发异常的程序，这个程序的作用就是检测发生了哪种异常，并调用相应的异常处理程序。</p><p>一般来说，异常分发程序会被要求放在 <strong>固定的某个物理地址上</strong>（根据处理器的区别有所不同），以保证处理器能在检测到异常时正确地跳转到那里。这个分发程序可以认为是操作系统的一部分。</p><p><strong>工作流程：</strong></p><ul><li>使用 <code>SAVE_ALL</code> 宏将当前上下文保存到内核的异常栈中。</li><li>清除 <code>Status</code> 寄存器中的 <code>UM</code> 、 <code>EXL</code> 、 <code>IE</code> 位，以保持处理器处于<strong>内核态</strong>（ <code>UM==0</code> ）、<strong>关闭中断</strong> 且 <strong>允许嵌套异常</strong>。</li><li>将 <code>Cause</code> 寄存器的内容拷贝到 <code>t0</code> 寄存器中。</li><li>取得 <code>Cause</code> 寄存器中的 <code>2~6</code> 位，也就是对应的异常码，这是区别不同异常的重要标志。</li><li>以得到的异常码作为索引在 <code>exception_handlers</code> 数组中找到对应的中断处理函数，后文中会有涉及。</li><li>跳转到对应的中断处理函数中，从而响应了异常，并将异常交给了对应的异常处理函数去处理</li></ul><p><strong>链接：</strong></p><p><code>.text.exc_gen_entry</code> 段和 <code>.text.tlb_miss_entry</code> 段需要被链接器放到特定的位置。在 <code>4Kc</code> 中，这两个段分别要求放到地址 <code>0x80000180</code> 和 <code>0x80000000</code> 处，它们是异常处理程序的入口地址。在我们的系统中:</p><ul><li><code>CPU</code> 发生异常（除了用户态地址的 <code>TLB Miss</code> 异常）后，就会自动跳转到地址 <code>0x80000180</code> 处；</li><li>发生用户态地址的 <code>TLB Miss</code> 异常时，会自动跳转到地址 <code>0x80000000</code> 处。开始执行。</li></ul><h4 id="exercise-39"><a class="anchor" href="#exercise-39">#</a> Exercise 3.9</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>exc_gen_entry<span class="token operator">:</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	SAVE_ALL</pre></td></tr><tr><td data-num="3"></td><td><pre>	mfc0    t0<span class="token punctuation">,</span> CP0_STATUS</pre></td></tr><tr><td data-num="4"></td><td><pre>	and     t0<span class="token punctuation">,</span> t0<span class="token punctuation">,</span> <span class="token operator">~</span><span class="token punctuation">(</span>STATUS_UM <span class="token operator">|</span> STATUS_EXL <span class="token operator">|</span> STATUS_IE<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	mtc0    t0<span class="token punctuation">,</span> CP0_STATUS</pre></td></tr><tr><td data-num="6"></td><td><pre>	</pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token comment">/* Exercise 3.9: Your code here. */</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	andi    t0<span class="token punctuation">,</span> <span class="token number">0x7c</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	lw      t0<span class="token punctuation">,</span> <span class="token function">exception_handlers</span><span class="token punctuation">(</span>t0<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	jr      t0</pre></td></tr></table></figure><h4 id="exercise-310"><a class="anchor" href="#exercise-310">#</a> Exercise 3.10</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>SECTIONS <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token comment">/* Exercise 3.10: Your code here. */</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token punctuation">.</span>tlb_miss_entry <span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>		<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span>text<span class="token punctuation">.</span>tlb_miss_entry<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token punctuation">.</span> <span class="token operator">=</span> <span class="token number">0x80000180</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token punctuation">.</span>exc_gen_entry <span class="token operator">:</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>		<span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">.</span>text<span class="token punctuation">.</span>exc_gen_entry<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    </pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token comment">//.....</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="异常向量组"><a class="anchor" href="#异常向量组">#</a> 异常向量组</h4><p>异常分发程序通过 <code>exception_handlers</code> 数组定位中断处理程序，而 <code>exception_handlers</code> 就称作异常向量组</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">handle_int</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">handle_tlb</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">handle_sys</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">handle_mod</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">extern</span> <span class="token keyword">void</span> <span class="token function">handle_reserved</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>exception_handlers<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token punctuation">[</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token number">31</span><span class="token punctuation">]</span> <span class="token operator">=</span> handle_reserved<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> handle_int<span class="token punctuation">,</span>				<span class="token comment">// 中断，由时钟中断、控制台中断造成</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> handle_mod<span class="token punctuation">,</span>				<span class="token comment">// 存储异常，进行存储操作时该页被标记为只读</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">[</span><span class="token number">2</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> handle_tlb<span class="token punctuation">,</span>			<span class="token comment">// 2 号寄存器为 TLB_load 异常，3 号寄存器为 TLB_store 异常</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">=</span> handle_sys<span class="token punctuation">,</span>				<span class="token comment">// 系统调用，用户进程通过执行 syscall 指令陷入内核</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>一旦初始化结束，有异常产生，那么其对应的处理函数就会得到执行。而我们在本 <code>Lab</code> 中，主要使用 0 号异常，即中断异常的处理函数我们接下来要做的，就是产生并处理时钟中断，利用时钟中断进行抢占式进程调度。</p><h4 id="时钟中断"><a class="anchor" href="#时钟中断">#</a> 时钟中断</h4><p>中断处理的流程：</p><ul><li>通过异常分发，判断出当前异常为中断异常，随后进入相应的中断处理程序。在 <code>MOS</code> 中即对应 <code>handle_int</code> 函数。</li><li>在中断处理程序中进一步判断 <code>Cause</code> 寄存器中是由几号中断位引发的中断，然后进入不同中断对应的中断服务函数。</li><li>中断处理完成，通过 <code>ret_from_exception</code> 函数恢复现场，继续执行。</li></ul><p>时钟中断与 MOS 系统的时间片轮转调度算法是紧密相关的。<strong>时间片轮转调度</strong> 是一种进程调度算法，每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</p><ul><li>如果在时间片结束时进程还在运行，则该进程将挂起，切换到另一个进程运行。</li><li>如果该进程在时间片结束前阻塞或者结束，则立即切换到另一个进程运行。</li></ul><p><code>4KC</code> 中的 <code>CP0</code> 内置了一个可产生中断的 <code>Timer</code> ， <code>MOS</code> 即使用这个内置的 <code>Timer</code> 产生时钟中断。CP0 中存在两个用于控制此内置 <code>Timer</code> 的寄存器，即 <code>Count</code> 寄存器与 <code>Compare</code> 寄存器。</p><ul><li><code>Count</code> 寄存器会按照某种仅与处理器流水线频率相关的频率不断自增，而 <code>Compare</code> 寄存器维持不变。</li><li>当 <code>Count</code> 寄存器的值与 <code>Compare</code> 寄存器的值相等且非 0 时，时钟中断会被立即触发。</li></ul><p><code>RESET_KCLOCK</code> 宏将 <code>Count</code> 寄存器清零并将 <code>Compare</code> 寄存器配置为我们所期望的计时器周期数，这就对 <code>Timer</code> 完成了配置。在设定个时钟周期后，时钟中断将被触发。</p><h4 id="exercise-311"><a class="anchor" href="#exercise-311">#</a> Exercise 3.11</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">.</span>macro RESET_KCLOCK</pre></td></tr><tr><td data-num="2"></td><td><pre>	li 	t0<span class="token punctuation">,</span> TIMER_INTERVAL</pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token comment">/* Exercise 3.11: Your code here. */</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	mtc0	zero<span class="token punctuation">,</span> CP0_COUNT</pre></td></tr><tr><td data-num="5"></td><td><pre>	mtc0 	t0<span class="token punctuation">,</span> CP0_COMPARE</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">.</span>endm</pre></td></tr></table></figure><hr><h3 id="进程调度"><a class="anchor" href="#进程调度">#</a> 进程调度</h3><p><code>handle_int</code> 函数的最后跳转到了 <code>schedule</code> 调度函数，调度算法即上文提到的 <strong>时间片轮转算法</strong></p><p>调度函数 <code>schedule</code> 被调用时，当前正在运行的进程被存储在全局变量 <code>curenv</code> 中（在第一个进程被调度前为 <code>NULL</code> ），其剩余的时间片长度被存储在静态变量 <code>count</code> 中。</p><ul><li><p>需要进行进程切换，包括以下几种情况：</p><ul><li><p>尚未调度过任何进程（ <code>curenv==NULL</code> ）</p></li><li><p>当前进程已经用完了时间片</p></li><li><p>当前进程不再就绪（如被阻塞或退出）</p></li><li><p>yield 参数指定必须发生切换</p></li></ul><p>我们还需要判断当前进程是否仍然就绪：</p><ul><li>如果是，则将其移动到调度链表的尾部。之后，我们选中调度链表头部的进程来调度运行，将剩余时间片长度设置为其优先级。</li><li>如果不是，直接切换链表头部的进程</li></ul></li><li><p>无需进行切换时：</p><ul><li><code>count--</code></li><li>调用 <code>env_run</code> 函数，继续运行当前进程 <code>curenv</code></li></ul></li></ul><h4 id="exercise-312"><a class="anchor" href="#exercise-312">#</a> Exercise 3.12</h4><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">int</span> yield<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">static</span> <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// remaining time slices of current env</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">Env</span> <span class="token operator">*</span>e <span class="token operator">=</span> curenv<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token comment">/* Exercise 3.12: Your code here. */</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token keyword">if</span> <span class="token punctuation">(</span>yield <span class="token operator">||</span> count <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> e <span class="token operator">==</span> <span class="token constant">NULL</span> <span class="token operator">||</span> e<span class="token operator">-></span>env_status <span class="token operator">!=</span> ENV_RUNNABLE<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> e<span class="token operator">-></span>env_status <span class="token operator">==</span> ENV_RUNNABLE<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>			<span class="token function">TAILQ_REMOVE</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">,</span> e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>			<span class="token function">TAILQ_INSERT_TAIL</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">,</span> e<span class="token punctuation">,</span> env_sched_link<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>		e <span class="token operator">=</span> <span class="token function">TAILQ_FIRST</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>env_sched_list<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>		<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>			<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"schedule: no runnable envs\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>		count <span class="token operator">=</span> e<span class="token operator">-></span>env_pri<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	count<span class="token operator">--</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	<span class="token function">env_run</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><div class="tags"><a href="/tags/%E5%AE%9E%E9%AA%8C/" rel="tag"><i class="ic i-tag"></i> 实验</a> <a href="/tags/OS/" rel="tag"><i class="ic i-tag"></i> OS</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-04-22 22:59:38" itemprop="dateModified" datetime="2025-04-22T22:59:38+08:00">2025-04-22</time> </span><span id="2025/04/15/OS/2025-04-15-OSLab3/" class="item leancloud_visitors" data-flag-title="OS-Lab3-进程与异常" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="CircleCoder 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="CircleCoder 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="CircleCoder 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>CircleCoder： </strong>CircleCoder <i class="ic i-at"><em>@</em></i>碼農書架</li><li class="link"><strong>本文链接：</strong> <a href="http://circlecoder05.github.io/2025/04/15/OS/2025-04-15-OSLab3/" title="OS-Lab3-进程与异常">http://circlecoder05.github.io/2025/04/15/OS/2025-04-15-OSLab3/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2025/04/12/OO/2025-04-12-unit2/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;circlecoder05.oss-cn-beijing.aliyuncs.com&#x2F;test&#x2F;202503311943439.jpg" title="OO-Unit2-多线程电梯"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 面向对象设计与构造</span><h3>OO-Unit2-多线程电梯</h3></a></div><div class="item right"><a href="/2025/04/16/OS/OS-Chapter2-selfMap/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;circlecoder05.oss-cn-beijing.aliyuncs.com&#x2F;test&#x2F;202503311943052.jpg" title="OS-页表自映射"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 操作系统</span><h3>OS-页表自映射</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84"><span class="toc-number">1.</span> <span class="toc-text">实验目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.</span> <span class="toc-text">进程控制块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97-pcb"><span class="toc-number">2.1.</span> <span class="toc-text">进程控制块 PCB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#env_init-%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">env_init 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exercise-31"><span class="toc-number">2.3.</span> <span class="toc-text">Exercise 3.1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map_segment-%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">map_segment 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exercise-32"><span class="toc-number">2.5.</span> <span class="toc-text">Exercise 3.2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#env_setup_vm-%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">env_setup_vm 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exercise-33"><span class="toc-number">2.7.</span> <span class="toc-text">Exercise 3.3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#env_alloc-%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.</span> <span class="toc-text">env_alloc 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exercise-34"><span class="toc-number">2.9.</span> <span class="toc-text">Exercise 3.4</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%98%A0%E5%83%8F"><span class="toc-number">3.</span> <span class="toc-text">加载二进制映像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#elf_from-%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">elf_from 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#elf_load_seg-%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">elf_load_seg 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#load_icode_mapper-%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">load_icode_mapper 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exercise-35"><span class="toc-number">3.4.</span> <span class="toc-text">Exercise 3.5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#load_icode-%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">load_icode 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exercise-36"><span class="toc-number">3.6.</span> <span class="toc-text">Exercise 3.6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="toc-number">4.</span> <span class="toc-text">进程的创建和运行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#env_create-%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">env_create 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exrercise-37"><span class="toc-number">4.2.</span> <span class="toc-text">Exrercise 3.7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#env_run-%E5%87%BD%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">env_run 函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exercise-38"><span class="toc-number">4.4.</span> <span class="toc-text">Exercise 3.8</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-number">5.</span> <span class="toc-text">中断与异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E5%8F%91"><span class="toc-number">5.1.</span> <span class="toc-text">异常的分发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exercise-39"><span class="toc-number">5.2.</span> <span class="toc-text">Exercise 3.9</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exercise-310"><span class="toc-number">5.3.</span> <span class="toc-text">Exercise 3.10</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%E7%BB%84"><span class="toc-number">5.4.</span> <span class="toc-text">异常向量组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD"><span class="toc-number">5.5.</span> <span class="toc-text">时钟中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exercise-311"><span class="toc-number">5.6.</span> <span class="toc-text">Exercise 3.11</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">6.</span> <span class="toc-text">进程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#exercise-312"><span class="toc-number">6.1.</span> <span class="toc-text">Exercise 3.12</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2025/03/04/OS/OS-Chapter0/" rel="bookmark" title="OS-Chapter0-引论">OS-Chapter0-引论</a></li><li><a href="/2025/03/07/OS/2025-3-07-Shell_gsa/" rel="bookmark" title="Shell 三剑客">Shell 三剑客</a></li><li><a href="/2025/03/11/OS/OS-Chapter1/" rel="bookmark" title="OS-Chapter1-系统引导">OS-Chapter1-系统引导</a></li><li><a href="/2025/03/25/OS/OS-Chapter2/" rel="bookmark" title="OS-Chapter2-内存管理">OS-Chapter2-内存管理</a></li><li><a href="/2025/03/27/OS/2025-3-27-OSLab1/" rel="bookmark" title="OS-Lab1上机回忆">OS-Lab1上机回忆</a></li><li><a href="/2025/03/31/OS/2025-3-31-OSLab2/" rel="bookmark" title="OS-Lab2-内存管理">OS-Lab2-内存管理</a></li><li><a href="/2025/04/03/OS/OS-Chapter3/" rel="bookmark" title="OS-Chapter3-进程与并发程序设计">OS-Chapter3-进程与并发程序设计</a></li><li><a href="/2025/04/10/OS/2025-04-10-OSLab2/" rel="bookmark" title="OS-Lab2-上机回忆">OS-Lab2-上机回忆</a></li><li class="active"><a href="/2025/04/15/OS/2025-04-15-OSLab3/" rel="bookmark" title="OS-Lab3-进程与异常">OS-Lab3-进程与异常</a></li><li><a href="/2025/04/16/OS/OS-Chapter2-selfMap/" rel="bookmark" title="OS-页表自映射">OS-页表自映射</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="CircleCoder" data-src="/images/avatar.jpg"><p class="name" itemprop="name">CircleCoder</p><div class="description" itemprop="description">空天报国，敢为人先</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">25</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">9</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0NpcmNsZUNvZGVyMDU=" title="https:&#x2F;&#x2F;github.com&#x2F;CircleCoder05"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <a href="/3196932484@qq.com" title="3196932484@qq.com" class="item email"><i class="ic i-envelope"></i></a></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/statistics/" rel="section"><i class="ic i-clock"></i>统计</a></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2025/04/12/OO/2025-04-12-unit2/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2025/04/16/OS/OS-Chapter2-selfMap/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/OS/" title="分类于 操作系统">操作系统</a></div><span><a href="/2025/03/31/OS/2025-3-31-OSLab2/" title="OS-Lab2-内存管理">OS-Lab2-内存管理</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/note/" title="分类于 杂谈">杂谈</a></div><span><a href="/2025/04/11/note/2025-04-11-OhMyLive2d/" title="基于 Oh-My-Live2d 的看板娘配置">基于 Oh-My-Live2d 的看板娘配置</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/OS/" title="分类于 操作系统">操作系统</a></div><span><a href="/2025/03/04/OS/OS-Chapter0/" title="OS-Chapter0-引论">OS-Chapter0-引论</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ML/" title="分类于 机器学习">机器学习</a></div><span><a href="/2025/03/14/ML/OS-Chapter2/" title="ML-Chapter2-模型评估与选择">ML-Chapter2-模型评估与选择</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CO/" title="分类于 计算机组成原理">计算机组成原理</a></div><span><a href="/2024/12/03/CO/2024-12-03-P7/" title="P7课上指令回忆">P7课上指令回忆</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2025/03/29/My-New-House/" title="My New House">My New House</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/OS/" title="分类于 操作系统">操作系统</a></div><span><a href="/2025/03/07/OS/2025-3-07-Shell_gsa/" title="Shell 三剑客">Shell 三剑客</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/OS/" title="分类于 操作系统">操作系统</a></div><span><a href="/2025/03/27/OS/2025-3-27-OSLab1/" title="OS-Lab1上机回忆">OS-Lab1上机回忆</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/OO/" title="分类于 面向对象设计与构造">面向对象设计与构造</a></div><span><a href="/2025/03/19/OO/2025-3-19-unit1/" title="OO-Unit1">OO-Unit1</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/CO/" title="分类于 计算机组成原理">计算机组成原理</a></div><span><a href="/2024/11/20/CO/2024-11-20-P6/" title="P6评测机说明">P6评测机说明</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2024 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">CircleCoder @ CircleCoder</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">99k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">2:59</span></div><div id="running-time">本站已稳定运行 <span id="years">0</span> 年 <span id="days">0</span> 天 <span id="hours">0</span> 小时 <span id="minutes">0</span> 分 <span id="seconds">0</span> 秒</div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_pv">总访问量：<span id="busuanzi_value_site_pv"></span>次</span> <span id="busuanzi_container_site_uv" style="margin-right:20px">总访客数：<span id="busuanzi_value_site_uv"></span>人</span></div><script>function updateRunningTime(){const e=new Date("2024-11-17T16:04:42"),t=new Date,n=t-e,o=Math.floor(n/1e3%60),d=Math.floor(n/1e3/60%60),m=Math.floor(n/1e3/60/60%24),u=Math.floor(n/1e3/60/60/24%365),a=Math.floor(n/1e3/60/60/24/365);document.getElementById("years").textContent=a,document.getElementById("days").textContent=u,document.getElementById("hours").textContent=m,document.getElementById("minutes").textContent=d,document.getElementById("seconds").textContent=o}updateRunningTime(),setInterval(updateRunningTime,1e3)</script></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2025/04/15/OS/2025-04-15-OSLab3/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js,npm/echarts@5.2.2/dist/echarts.min.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?635dc74186a0fb746883381993b3feb9";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script data-pjax src="https://unpkg.com/oh-my-live2d"></script><script>const oml2d=OML2D.loadOml2d({dockedPosition:"left",mobileDisplay:!0,models:[{path:"https://unpkg.com/live2d-widget-model-shizuku@1.0.5/assets/shizuku.model.json",mobilePosition:[0,23],mobileScale:.1,mobileStageStyle:{width:180,height:250},motionPreloadStrategy:"IDLE",position:[0,30],scale:.18,stageStyle:{width:250,height:250}},{path:"https://unpkg.com/cc-tia@1.0.0/model.json",scale:.3,position:[0,-120],mobileScale:.08,mobilePosition:[0,0],mobileStageStyle:{width:180},stageStyle:{width:320}},{path:["https://unpkg.com/live2d-widget-model-koharu@1.0.5/assets/koharu.model.json","https://unpkg.com/live2d-widget-model-haruto@1.0.5/assets/haruto.model.json"],scale:.12,position:[0,0],stageStyle:{width:250},mobileScale:.08,mobilePosition:[0,0],mobileStageStyle:{width:180}},{path:["https://unpkg.com/cat-white@1.0.0/model.json","https://unpkg.com/cat-black@1.0.0/model.json"],scale:.12,position:[0,10],mobileScale:.08,mobilePosition:[0,0],mobileStageStyle:{width:180},stageStyle:{width:250}},{path:["https://unpkg.com/hk416-1-normal@1.0.0/model.json","https://unpkg.com/hk416-2-normal@1.0.0/model.json","https://unpkg.com/hk416-2-destroy@1.0.0/model.json"],scale:.09,position:[-30,0],mobileScale:.08,mobilePosition:[0,0],mobileStageStyle:{width:180},stageStyle:{width:340}},{path:"https://unpkg.com/kar98k-normal@1.0.0/model.json",scale:.09,position:[0,10],mobileScale:.08,mobilePosition:[0,0],mobileStageStyle:{width:180},stageStyle:{width:340}},{path:"https://unpkg.com/cc-histoire@1.0.0/model.json",scale:.3,position:[0,-130],mobileScale:.08,mobilePosition:[0,0],mobileStageStyle:{width:180},stageStyle:{width:320}}],parentElement:document.body,primaryColor:"#38B0DE",sayHello:!1,tips:{style:{width:230,height:120,left:"calc(50%)",top:"-100px"},mobileStyle:{width:180,height:80,left:"calc(50% - 30px)",top:"-100px"},idleTips:{interval:15e3,message:function(){return axios.get("https://v1.hitokoto.cn?c=i").then(function(t){return t.data.hitokoto})["catch"](function(t){console.error(t)})}}}})</script></body></html><!-- rebuild by hrmmi -->